"""
Non-autonomous dynamic systems.

Chaotic nonlinear ODEs
    + https://en.wikipedia.org/wiki/List_of_chaotic_maps
"""
import numpy as np
import inspect, sys
import warnings
import random
warnings.filterwarnings("ignore")
from scipy.integrate import odeint
from tqdm.auto import tqdm
from psl.emulator import EmulatorBase
from psl.perturb import Steps, Step, SplineSignal, Periodic, RandomWalk, WhiteNoise
from tqdm.auto import tqdm


class ODE_NonAutonomous:
    """
    base class non-autonomous ODE
    """
    def __init__(self, nsim=1001, ninit=0, ts=0.1, seed=59):
        super().__init__()
        random.seed(seed)
        np.random.seed(seed)
        self.seed = seed
        self.nsim, self.ninit, self.ts = nsim, ninit, ts
        self.x0 = 0.

    def simulate(self, U=None, ninit=None, nsim=None, Time=None, ts=None, x0=None, show_progress=False):
        """
        :param nsim: (int) Number of steps for open loop response
        :param ninit: (float) initial simulation time
        :param ts: (float) step size, sampling time
        :param x0: (float) state initial conditions
        :return: X, Y, U, D
        """
        if ninit is None:
            ninit = self.ninit
        if nsim is None:
            nsim = self.nsim
        if ts is None:
            ts = self.ts
        if U is None:
            U = self.U
        if Time is None:
            Time = np.arange(0, nsim+1) * ts + ninit
        if x0 is None:
            x = self.x0
        else:
            assert x0.shape[0] % self.nx == 0, "Mismatch in x0 size"
            x = x0
        X = [x]
        N = 0
        simrange = tqdm(U) if show_progress else U
        for u in simrange:
            if len(Time) == 1:
                dT = [Time[0], Time[0]+ts]
            else:
                dT = [Time[N], Time[N + 1]]
            xdot = odeint(self.equations, x, dT, args=(u,))
            x = xdot[-1]
            X.append(x)
            N += 1
            if N == nsim:
                break
        Yout = np.asarray(X).reshape(nsim+1, -1)
        Uout = U.reshape(nsim, -1)
        return {'Y': Yout, 'U': Uout, 'X': np.asarray(X)}

    def get_stats(self):
        """
        Get a hyperbox defined by min and max values on each of nx axes. Used to sample initial conditions for simulations.
        Box is generated by simulating system with step size ts for nsim steps and then taking the min and max along each axis

        :param system: (psl.ODE_NonAutonomous)
        :param ts: (float) Timestep interval size
        :param nsim: (int) Number of simulation steps to use in defining box
        """
        sim = self.simulate()
        X, U = sim['X'], sim['U']
        self.xstats = {'min': X.min(axis=0), 'max': X.max(axis=0),
                       'mean': X.mean(axis=0), 'var': X.var(axis=0),
                       'std': X.std(axis=0)}
        self.ustats = {'min': U.min(axis=0), 'max': U.max(axis=0),
                       'mean': U.mean(axis=0), 'var': U.var(axis=0),
                       'std': U.std(axis=0)}

    def get_x0(self):
        """
        Randomly sample an initial condition

        :param box: Dictionary with keys 'min' and 'max' and values np.arrays with shape=(nx,)
        """
        return np.random.uniform(low=self.xstats['min'], high=self.xstats['max'])

    def get_U(self, nsim):
        return np.random.normal(loc=self.ustats['mean'], scale=self.ustats['std'],
                                size=(nsim, self.nu))


class LorenzControl(ODE_NonAutonomous):

    def __init__(self, nsim=1001, ninit=0, ts=0.01, seed=59):
        super().__init__(nsim=nsim, ninit=ninit, ts=ts, seed=seed)
        self.sigma = 10.
        self.beta = 2.66667
        self.rho = 28
        self.x0 = np.asarray([-8., 8., 27.])
        self.nx = 3
        self.nu = 2
        self.ts = 0.01
        self.ninit = 0.
        self.nsim = 1000
        self.U = self.get_U(self.nsim)
        self.get_stats()

    def get_U(self, nsim):
        t = np.random.uniform(low=0, high=np.pi)
        self.ninit = t
        T = np.arange(t, t + self.ts * nsim, self.ts)
        return self.u_fun(T).T[:nsim]

    def equations(self, x, t, u):
        return [
            self.sigma * (x[1] - x[0]) + u[0],
            x[0] * (self.rho - x[2]) - x[1],
            x[0] * x[1] - self.beta * x[2] - u[1],
        ]

    def u_fun(self, t):
        return np.array([np.sin(2 * t), np.sin(8 * t)])


class SEIR_population(ODE_NonAutonomous):
    """
    Susceptible, Exposed, Infected, and Recovered (SEIR) population population model. Used to model COVID-19 spread.
    Source of the model:

    + https://apmonitor.com/do/index.php/Main/COVID-19Response

    states:

    + Susceptible (s): population fraction that is susceptible to the virus
    + Exposed (e): population fraction is infected with the virus but does not transmit to others
    + Infectious (i): population fraction that is infected and can infect others
    + Recovered (r): population fraction recovered from infection and is immune from further infection
    """

    def __init__(self, nsim=1001, ninit=0, ts=0.01, seed=59):
        super().__init__(nsim=nsim, ninit=ninit, ts=ts, seed=seed)
        self.N = 10000 # population
        # initial number of infected and recovered individuals
        self.e_0 = 1 / self.N
        self.i_0 = 0.00
        self.r_0 = 0.00
        self.s_0 = 1 - self.e_0 - self.i_0 - self.r_0
        self.x0 = np.asarray([self.s_0, self.e_0, self.i_0, self.r_0])

        self.nx = 4
        self.nu = 1

        self.t_incubation = 5.1
        self.t_infective = 3.3
        self.R0 = 2.4
        self.alpha = 1 / self.t_incubation
        self.gamma = 1 / self.t_infective
        self.beta = self.R0 * self.gamma
        self.U = self.get_U(self.nsim)
        self.get_stats()

    def get_U(self, nsim):
        return Steps(nx=self.nu, nsim=nsim, values=None,
                     randsteps=int(np.ceil(self.nsim / 24)), xmax=1, xmin=0)

    def equations(self, x, t, u):
        """

        +  Inputs (1): social distancing (u=0 (none), u=1 (total isolation))
        +  States (4):
        +  Susceptible (s): population fraction that is susceptible to the virus
        +  Exposed (e): population fraction is infected with the virus but does not transmit to others
        +  Infectious (i): population fraction that is infected and can infect others
        +  Recovered (r): population fraction recovered from infection and is immune from further infection
        """

        s = x[0]
        e = x[1]
        i = x[2]
        u = u[0]

        sdt = -(1 - u) * self.beta * s * i
        edt = (1 - u) * self.beta * s * i - self.alpha * e
        idt = self.alpha * e - self.gamma * i
        rdt = self.gamma * i
        dx = [sdt, edt, idt, rdt]
        return dx


class Tank(ODE_NonAutonomous):
    """
    Single Tank model
    Original code obtained from APMonitor:

    + https://apmonitor.com/pdc/index.php/Main/TankLevel
    """

    def __init__(self, nsim=1001, ninit=0, ts=0.1, seed=59):
        super().__init__(nsim=nsim, ninit=ninit, ts=ts, seed=seed)
        self.rho = 1000.0  # water density (kg/m^3)
        self.A = 1.0  # tank area (m^2)
        self.x0 = np.array([0.])
        self.U = self.get_U(self.nsim)
        self.nu = 2
        self.nx = 1
        self.get_stats()

    def get_x0(self):
        return np.random.uniform(low=0.0, high=0.1, size=(1,))

    def get_U(self, nsim):
        c = Steps(nx=1, nsim=nsim, values=None,
                  randsteps=int(np.ceil(nsim / 48)), xmax=55, xmin=0.1)
        valve = Periodic(nx=1, nsim=nsim,
                         numPeriods=int(np.ceil(nsim / 48)), xmax=10., xmin=0., form='sin') + WhiteNoise(1, nsim=nsim)
        return np.vstack([c.T, valve.T]).T

    def equations(self, x, t, u):
        """

        + States (1): level in the tanks
        + Inputs u(1): c - valve coefficient (kg/s / %open)
        + Inputs u(2): valve in % [0-100]
        """

        c = u[0]
        valve = u[1]
        dx_dt = (c / (self.rho*self.A)) * valve
        return dx_dt


class TwoTank(ODE_NonAutonomous):
    """
    Two Tank model
    Original code obtained from APMonitor:

    + https://apmonitor.com/do/index.php/Main/LevelControl
    """

    def __init__(self, nsim=1001, ninit=0, ts=1., seed=59):
        super().__init__(nsim=nsim, ninit=ninit, ts=ts, seed=seed)
        self.ts = ts
        self.c1 = 0.08  # inlet valve coefficient
        self.c2 = 0.04  # tank outlet coefficient

        self.x0 = np.asarray([0, 0])
        self.U = self.get_U(self.nsim)
        self.nu = 2
        self.nx = 2
        self.get_stats()

    def get_x0(self):
        return np.random.uniform(low=0.0, high=0.5, size=2)

    def get_U(self, nsim):
        pump = Steps(nx=1, nsim=nsim, values=None,
                     randsteps=int(np.ceil(self.ts*nsim/300)), xmax=0.5, xmin=0)
        valve = Steps(nx=1, nsim=nsim, values=None,
                      randsteps=int(np.ceil(self.ts*nsim/420)), xmax=0.4, xmin=0)
        return np.vstack([pump.T, valve.T]).T

    def equations(self, x, t, u):
        # States (2): level in the tanks
        h1 = x[0]
        h2 = x[1]
        # Inputs (2): pump and valve
        pump = u[0]
        valve = u[1]
        dhdt1 = self.c1 * (1.0 - valve) * pump - self.c2 * np.sqrt(h1)
        dhdt2 = self.c1 * valve * pump + self.c2 * np.sqrt(h1) - self.c2 * np.sqrt(h2)
        if h1 >= 1.0 and dhdt1 > 0.0:
            dhdt1 = 0
        if h2 >= 1.0 and dhdt2 > 0.0:
            dhdt2 = 0
        dhdt = [dhdt1, dhdt2]
        return dhdt


class CSTR(ODE_NonAutonomous):
    """
    CSTR model
    Original code obtained from APMonitor:

    + http://apmonitor.com/do/index.php/Main/NonlinearControl
    """

    def __init__(self, nsim=1001, ninit=0, ts=0.1, seed=59):
        super().__init__(nsim=nsim, ninit=ninit, ts=ts, seed=seed)
        # Volumetric Flowrate (m^3/sec)
        self.q = 100
        # Volume of CSTR (m^3)
        self.V = 100
        # Density of A-B Mixture (kg/m^3)
        self.rho = 1000
        # Heat capacity of A-B Mixture (J/kg-K)
        self.Cp = 0.239
        # Heat of reaction for A->B (J/mol)
        self.mdelH = 5e4
        # E - Activation energy in the Arrhenius Equation (J/mol)
        # R - Universal Gas Constant = 8.31451 J/mol-K
        self.EoverR = 8750
        # Pre-exponential factor (1/sec)
        self.k0 = 7.2e10
        # U - Overall Heat Transfer Coefficient (W/m^2-K)
        # A - Area - this value is specific for the U calculation (m^2)
        self.UA = 5e4
        # Steady State Initial Conditions for the States
        self.Ca_ss = 0.87725294608097
        self.T_ss = 324.475443431599
        self.x0 = np.empty(2)
        self.x0[0] = self.Ca_ss
        self.x0[1] = self.T_ss
        # Steady State Initial Condition for the Uncontrolled Inputs
        self.u_ss = 300.0  # cooling jacket Temperature (K)
        self.Tf = 350  # Feed Temperature (K)
        self.Caf = 1  # Feed Concentration (mol/m^3)
        self.nx = 2
        self.nu = 1
        self.nd = 2
        self.U = self.get_U(self.nsim)
        self.get_stats()

    def get_x0(self):
        x1 = np.random.normal(loc=self.Ca_ss)
        x2 = np.random.normal(loc=self.T_ss, scale=0.01)
        # return np.array([x1, x2])
        return np.array([self.Ca_ss, self.T_ss])

    def get_U(self, nsim):
        return self.u_ss + Steps(nx=1, nsim=nsim, values=None,
                                 randsteps=int(np.ceil(nsim / 25)), xmax=3, xmin=-3) #+ Periodic(nx=1, nsim=nsim, numPeriods=int(np.ceil(nsim / 10)), xmax=1, xmin=-1, form='sin')

    def equations(self, x, t, u):
        # Inputs (1):
        # Temperature of cooling jacket (K)
        Tc = u
        # Disturbances (2):
        # Tf = Feed Temperature (K)
        # Caf = Feed Concentration (mol/m^3)
        # States (2):
        # Concentration of A in CSTR (mol/m^3)
        Ca = x[0]
        # Temperature in CSTR (K)
        T = x[1]

        # reaction rate
        rA = self.k0 * np.exp(-self.EoverR / T) * Ca
        # Calculate concentration derivative
        dCadt = self.q / self.V * (self.Caf - Ca) - rA
        # Calculate temperature derivative
        dTdt = self.q / self.V * (self.Tf - T) \
               + self.mdelH / (self.rho * self.Cp) * rA \
               + self.UA / self.V / self.rho / self.Cp * (Tc - T)
        xdot = np.zeros(2)
        xdot[0] = dCadt
        xdot[1] = dTdt
        return xdot


class InvPendulum(ODE_NonAutonomous):
    """
    Inverted Pendulum dynamics
    states: x = [\theta \dot{\theta}]; \theta is angle from upright equilibrium
    input: u = input torque

    """

    def __init__(self, nsim=1001, ninit=0, ts=0.1, seed=59):
        super().__init__(nsim=nsim, ninit=ninit, ts=ts, seed=seed)
        self.nx = 2  # Number of states
        self.nu = 1  # Number of control inputs
        self.g = 9.81  # Acceleration due to gravity (m/s^2)
        self.L = 0.5  # length of the pole in m
        self.m = 0.15  # ball mass in kg
        self.b = 0.1  # friction
        self.x0 = [0.5, 0.0]
        self.U = self.get_U(self.nsim)
        self.get_stats()

    def get_U(self, nsim):
        return 0.1*np.random.normal(size=(nsim, self.nu))
        # return np.zeros(nsim)

    def equations(self, x, t, u):
        y = [x[1],
            (self.m * self.g * self.L * np.sin(x[0]) - self.b * x[1]) / (self.m * self.L ** 2)]
        y[1] = y[1] + (u / (self.m * self.L ** 2))
        return y


class HindmarshRose(ODE_NonAutonomous):
    """
    Hindmarsh–Rose model of neuronal activity

    + https://en.wikipedia.org/wiki/Hindmarsh%E2%80%93Rose_model
    + https://demonstrations.wolfram.com/HindmarshRoseNeuronModel/
    """

    def __init__(self, nsim=1001, ninit=0, ts=0.1, seed=59):
        super().__init__(nsim=nsim, ninit=ninit, ts=ts, seed=seed)
        self.a = 1
        self.b = 2.6
        self.c = 1
        self.d = 5
        self.s = 4
        self.xR = -8/5
        self.r = 0.01
        self.umin = -10
        self.umax = 10
        self.x0 = np.asarray([-5., -10., 0.])
        self.U = self.get_U(self.nsim)
        self.nu = 1
        self.nx = 3
        self.get_stats()

    def get_U(self, nsim):
        return Steps(nx=1, nsim=nsim, randsteps=int(max(1, nsim/48)), xmin=2.99, xmax=3.1)

    def equations(self, x, t, u):
        theta = -self.a*x[0]**3 + self.b*x[0]**2
        phi = self.c -self.d*x[0]**2
        dx1 = x[1] + theta - x[2] + u
        dx2 = phi - x[1]
        dx3 = self.r*(self.s*(x[0]-self.xR)-x[2])
        dx = [dx1, dx2, dx3]
        return dx


class Iver_dyn_simplified(ODE_NonAutonomous):
    """
    Dynamic model of Unmanned Underwater Vehicle (modified from Stankiewicz et al) -- Excludes rolling, sway, currents, Includes: hydrostate/dynamic terms, control surface deflections/propeller thrust, and actuator dynamics
    """

    def __init__(self, nsim=1001, ninit=0, ts=0.1, seed=3):
        super().__init__(nsim=nsim, ninit=ninit, ts=ts, seed=seed)
        self.nx = 12    # Number of states (including actuator dynamics)
        self.nu = 3    # Number of control inputs
        self.ts = ts

        self.Mq = -0.748        # Hydrodynamic coefficient (1/s)
        self.Nur = -0.441       # Hydrodynamic coefficient (1/m)
        self.Xuu = -0.179       # Hydrodynamic coefficient (1/m)
        self.Zww = 0.098        # Hydrodynamic coefficient (1/m)
        self.Muq = -3.519       # Hydrodynamic coefficient (1/m)
        self.WB = 0.0           # Out-of-ballast term based on weight and buoyancy ratio (m/s^2) (Differs from Stankiewicz, here set to zero for neutral buoyancy)
        self.Bz = 8.947         # Bouyancy term that accounts for the center of bouyancy vertical offset from the center of gravity (1/s^2)
        self.k = 0.519          # Hydrodynamic coefficient (m/s^2)
        self.b = 3.096          # Hydrodynamic coefficient (1/m^2)
        self.c = 0.065          # Hydrodynamic coefficient (1/m^2)
        self.K_delta_u = -10.0   # Thruster dynamic coefficient
        self.K_delta_q = -10.0   # Elevator deflection dynamic coefficient
        self.K_delta_r = -10.0   # Rudder deflection dynamic coefficient

        self.x0 = np.array([0, 0, 0, 0, 0, 0.01, 0, 0, 0, 0, 0, 0])
        self.U = self.get_U(self.nsim)
        self.get_stats()

    def get_U(self, nsim):
        seed = self.seed
        delta_u = Steps(nsim=nsim, values=None, randsteps=100, xmin=0.0, xmax=1.0, rseed=seed).T
        delta_q = Steps(nsim=nsim, values=None, randsteps=100, xmin=-1.0, xmax=1.0, rseed=2 * seed).T
        delta_r = Steps(nsim=nsim, values=None, randsteps=100, xmin=-1.0, xmax=1.0, rseed=3 * seed).T
        return np.vstack( [delta_u, delta_q, delta_r] ).T

    def equations(self, x, t, u):
        """
        + States (12): [px, py, pz, theta, psi, uu, w, q, r, delta_u, delta_q, delta_r]
        + Inputs (3): [delta_uc, delta_qc, delta_rc] (thrust speed/deflections, normalized)
        """
        theta = x[3]
        psi = x[4]
        uu = x[5]
        w = x[6]
        q = x[7]
        r = x[8]
        delta_u = x[9]
        delta_q = x[10]
        delta_r = x[11]

        delta_uc = u[0]
        delta_qc = u[1]
        delta_rc = u[2]

        # Kinematics:
        dx_dt = np.zeros(12)
        dx_dt[0] = uu*np.cos(psi)*np.cos(theta) + w*np.cos(psi)*np.sin(theta)
        dx_dt[1] = uu*np.sin(psi)*np.cos(theta) + w*np.sin(psi)*np.sin(theta)
        dx_dt[2] = w*np.cos(theta) - uu*np.sin(theta)
        dx_dt[3] = q
        dx_dt[4] = r / (np.cos(theta))

        # Dynamics
        dx_dt[5] = self.Xuu*(uu**2) + self.k*delta_u
        dx_dt[6] = self.Zww*w*np.absolute(w) + self.WB*np.cos(theta)
        dx_dt[7] = self.Muq*uu*q + self.Mq*q - self.Bz*np.sin(theta) + self.b*(uu**2)*delta_q
        dx_dt[8] = self.Nur*uu*r + self.c*(uu**2)*delta_r

        # Actuator dynamics:
        dx_dt[9] = self.K_delta_u*( delta_u - delta_uc )
        dx_dt[10] = self.K_delta_q*( delta_q - delta_qc )
        dx_dt[11] = self.K_delta_r*( delta_r - delta_rc )

        return dx_dt


class Iver_dyn_simplified_output(ODE_NonAutonomous):
    """
    Dynamic model of Unmanned Underwater Vehicle (modified from Stankiewicz et al) -- Excludes rolling, sway, currents, Includes: hydrostate/dynamic terms, control surface deflections/propeller thrust, and actuator dynamics
    with non-kinematic output
    """

    def __init__(self, nsim=1001, ninit=0, ts=0.1, seed=3):
        super().__init__(nsim=nsim, ninit=ninit, ts=ts, seed=seed)
        self.nx = 9    # Number of states (including actuator dynamics)
        self.nu = 3    # Number of control inputs
        self.ts = 0.1

        # Model parameters
        self.Mq = -0.748        # Hydrodynamic coefficient (1/s)
        self.Nur = -0.441       # Hydrodynamic coefficient (1/m)
        self.Xuu = -0.179       # Hydrodynamic coefficient (1/m)
        self.Zww = 0.098        # Hydrodynamic coefficient (1/m)
        self.Muq = -3.519       # Hydrodynamic coefficient (1/m)
        self.WB = 0.0           # Out-of-ballast term based on weight and buoyancy ratio (m/s^2) (Differs from Stankiewicz, here set to zero for neutral buoyancy)
        self.Bz = 8.947         # Bouyancy term that accounts for the center of bouyancy vertical offset from the center of gravity (1/s^2)
        self.k = 0.519          # Hydrodynamic coefficient (m/s^2)
        self.b = 3.096          # Hydrodynamic coefficient (1/m^2)
        self.c = 0.065          # Hydrodynamic coefficient (1/m^2)
        self.K_delta_u = -10.0   # Thruster dynamic coefficient
        self.K_delta_q = -10.0   # Elevator deflection dynamic coefficient
        self.K_delta_r = -10.0   # Rudder deflection dynamic coefficient

        self.x0 = np.array([0, 0, 0.01, 0, 0, 0, 0, 0, 0])
        self.U = self.get_U(self.nsim)
        self.get_stats()

    def get_U(self, nsim):
        seed = 3
        delta_u = Steps(nsim=nsim, values=None, randsteps=100, xmin=0.0, xmax=1.0, rseed=seed).T
        delta_q = Steps(nsim=nsim, values=None, randsteps=100, xmin=-1.0, xmax=1.0, rseed=2 * seed).T
        delta_r = Steps(nsim=nsim, values=None, randsteps=100, xmin=-1.0, xmax=1.0, rseed=3 * seed).T

        return np.vstack( [delta_u, delta_q, delta_r] ).T

    def equations(self, x, t, u):
        """
        + States (9): [theta, psi, uu, w, q, r, delta_u, delta_q, delta_r]
        + Inputs (3): [delta_uc, delta_qc, delta_rc] (thrust speed/deflections, normalized)
        """

        # States
        theta = x[0]
        psi = x[1]
        uu = x[2]
        w = x[3]
        q = x[4]
        r = x[5]
        delta_u = x[6]
        delta_q = x[7]
        delta_r = x[8]

        # Control
        delta_uc = u[0]
        delta_qc = u[1]
        delta_rc = u[2]

        # Kinematics:
        dx_dt = np.zeros(9)
        dx_dt[0] = q
        dx_dt[1] = r / (np.cos(theta))

        # Dynamics
        dx_dt[2] = self.Xuu*(uu**2) + self.k*delta_u
        dx_dt[3] = self.Zww*w*np.absolute(w) + self.WB*np.cos(theta)
        dx_dt[4] = self.Muq*uu*q + self.Mq*q - self.Bz*np.sin(theta) + self.b*(uu**2)*delta_q
        dx_dt[5] = self.Nur*uu*r + self.c*(uu**2)*delta_r

        # Actuator dynamics:
        dx_dt[6] = self.K_delta_u*( delta_u - delta_uc )
        dx_dt[7] = self.K_delta_q*( delta_q - delta_qc )
        dx_dt[8] = self.K_delta_r*( delta_r - delta_rc )

        return dx_dt


class IverSimple(ODE_NonAutonomous):
    """
    Dynamic model of Unmanned Underwater Vehicle (modified from Stankiewicz et al) -- Excludes rolling, sway, currents, Includes: hydrostate/dynamic terms, control surface deflections/propeller thrust, and actuator dynamics
    with non-kinematic output
    """

    def __init__(self, nsim=1001, ninit=0, ts=0.01, seed=3):
        super().__init__(nsim=nsim, ninit=ninit, ts=ts, seed=seed)
        self.x0 = np.array([0, 0, 0.01, 0, 0, 0, 0, 0])
        self.U = self.get_U(nsim)
        self.nx = 8   # Number of states (including actuator dynamics)
        self.nu = 3    # Number of control inputs
        self.ts = ts

        # Model parameters
        self.Mq = -0.748        # Hydrodynamic coefficient (1/s)
        self.Nur = -0.441       # Hydrodynamic coefficient (1/m)
        self.Xuu = -0.179       # Hydrodynamic coefficient (1/m)
        self.Zww = 0.098        # Hydrodynamic coefficient (1/m)
        self.Muq = -3.519       # Hydrodynamic coefficient (1/m)
        self.Bz = 8.947         # Bouyancy term that accounts for the center of bouyancy vertical offset from the center of gravity (1/s^2)
        self.k = 0.519          # Hydrodynamic coefficient (m/s^2)
        self.b = 3.096          # Hydrodynamic coefficient (1/m^2)
        self.c = 0.065          # Hydrodynamic coefficient (1/m^2)
        self.K_delta_u = -10.0   # Thruster dynamic coefficient
        self.K_delta_q = -10.0   # Elevator deflection dynamic coefficient
        self.K_delta_r = -10.0   # Rudder deflection dynamic coefficient
        self.get_stats()

    def get_U(self, nsim):
        seed = 3
        delta_u = Steps(nsim=nsim, values=None, randsteps=100, xmin=0.0, xmax=1.0).T
        delta_q = Steps(nsim=nsim, values=None, randsteps=100, xmin=-1.0, xmax=1.0).T
        delta_r = Steps(nsim=nsim, values=None, randsteps=100, xmin=-1.0, xmax=1.0).T
        return np.vstack([delta_u, delta_q, delta_r]).T

    def equations(self, x, t, u):
        """
        + States (8): [theta, psi, uu, q, r, delta_u, delta_q, delta_r]
        + Inputs (3): [delta_uc, delta_qc, delta_rc] (thrust speed/deflections, normalized)
        """

        # States
        theta = x[0]
        psi = x[1]
        uu = x[2]
        q = x[3]
        r = x[4]
        delta_u = x[5]
        delta_q = x[6]
        delta_r = x[7]

        # Control
        delta_uc = u[0]
        delta_qc = u[1]
        delta_rc = u[2]

        # Kinematics:
        dx_dt = np.zeros(8)
        dx_dt[0] = q
        dx_dt[1] = r / (np.cos(theta))

        # Dynamics
        dx_dt[2] = self.Xuu*(uu**2) + self.k*delta_u
        dx_dt[3] = self.Muq*uu*q + self.Mq*q - self.Bz*np.sin(theta) + self.b*(uu**2)*delta_q
        dx_dt[4] = self.Nur*uu*r + self.c*(uu**2)*delta_r

        # Actuator dynamics:
        dx_dt[5] = self.K_delta_u*( delta_u - delta_uc )
        dx_dt[6] = self.K_delta_q*( delta_q - delta_qc )
        dx_dt[7] = self.K_delta_r*( delta_r - delta_rc )

        return dx_dt


class Actuator(ODE_NonAutonomous):
    """
    These are the actuator dynamics from the IVER systems.
    Since the equations are linear they are a good sanity check for your modeling implementations.
    """

    def __init__(self, nsim=1001, ninit=0, ts=0.1, seed=3):
        super().__init__(nsim=nsim, ninit=ninit, ts=ts, seed=seed)
        self.nx = 3   # Number of states (including actuator dynamics)
        self.nu = 3    # Number of control inputs
        self.ts = ts

        # Model parameters
        self.K_delta_u = -10.0   # Thruster dynamic coefficient
        self.K_delta_q = -10.0   # Elevator deflection dynamic coefficient
        self.K_delta_r = -10.0   # Rudder deflection dynamic coefficient

        self.x0 = np.array([0., 0., 0.])
        self.U = self.get_U(self.nsim)

    def get_U(self, nsim):
        delta_u = Steps(nsim=nsim, values=None, randsteps=100, xmin=0.0, xmax=1.0).T
        delta_q = Steps(nsim=nsim, values=None, randsteps=100, xmin=-1.0, xmax=1.0).T
        delta_r = Steps(nsim=nsim, values=None, randsteps=100, xmin=-1.0, xmax=1.0).T
        return np.vstack([delta_u, delta_q, delta_r]).T

    def equations(self, x, t, u):
        """
        + States (8): [delta_u, delta_q, delta_r]
        + Inputs (3): [delta_uc, delta_qc, delta_rc] (thrust speed/deflections, normalized)
        """
        # States
        delta_u = x[0]
        delta_q = x[1]
        delta_r = x[2]

        # Control
        delta_uc = u[0]
        delta_qc = u[1]
        delta_rc = u[2]

        # Actuator dynamics:
        dx_dt = np.zeros(3)
        dx_dt[0] = self.K_delta_u * (delta_u - delta_uc)
        dx_dt[1] = self.K_delta_q * (delta_q - delta_qc)
        dx_dt[2] = self.K_delta_r * (delta_r - delta_rc)

        return dx_dt


class SwingEquation(ODE_NonAutonomous):
    """
    Power Grid Swing Equation.

    + https://en.wikipedia.org/wiki/Swing_equation
    + The second-order swing equation is converted to
    + two first-order ODEs
    """

    def __init__(self, nsim=1001, ninit=0, ts=0.1, seed=3):
        super().__init__(nsim=nsim, ninit=ninit, ts=ts, seed=seed)
        self.Pm = 0.8  # Mechanical power
        self.Pmax = 5.0  # Maximum electrical output
        self.H = 500.0  # Inertia constant
        self.D = 5.0  # Damping coefficient
        self.freq = 60.0  # Base frequency
        self.ws = 2 * np.pi * self.freq  # Base angular speed
        self.M = 2 * self.H / self.ws  # scaled inertia constant
        self.nx = 2  # number of variables
        self.mode = 1  # 0 (Constant mechanical power and Pmax)
        # 1 (Noisy mechanical power with constant Pmax)
        # 2 (Constant mechanical power with fault on-off Pmax (square wave))

        if (self.mode == 0):
            self.delta0 = 0.0
        else:
            self.delta0 = np.arcsin(self.Pm / self.Pmax)  # initial condition for machine angle \delta

        self.dw0 = 0.0  # initial condition for machine speed deviation d\omega
        self.x0 = [self.delta0, self.dw0]  # initial condition for the model

        self.ts = 0.01  # Time-step
        self.ninit = 0.0  # Simulation start at t=0
        self.nsim = 1000  # 1000 steps = 10 sec. horizon
        self.tfaulton = 0.05
        self.tfaultoff = 0.15
        self.U = self.get_U(self.nsim)
        self.get_stats()

    def get_U(self, nsim):
        if (self.mode == 0):
            # 0 (Constant mechanical power and Pmax)
            Pmech = Step(nx=1, nsim=nsim, tstep=100, xmax=self.Pm, xmin=self.Pm, rseed=1)
            Pmax = Step(nx=1, nsim=nsim, tstep=100, xmax=self.Pmax, xmin=self.Pmax, rseed=1)
            self.U = np.vstack([Pmech.T, Pmax.T]).T
            self.nu = 2
        elif (self.mode == 1):
            # 1 (Noisy mechanical power with constant Pmax)
            Pmech = RandomWalk(nx=1, nsim=nsim, xmax=self.Pm * 1.02, xmin=self.Pm * 0.98, sigma=0.1, rseed=1)
            self.U = Pmech
            self.nu = 1
        else:
            # 2 (Constant mechanical power with fault on-off Pmax (square wave))
            Signal = []
            signal = []
            for tstep in range(0, nsim):
                t = tstep * self.ts
                if (t < self.tfaulton):  # Pre-fault
                    signal.append(self.Pmax)
                elif (t >= self.tfaulton and t <= self.tfaultoff):  # Fault-on
                    signal.append(0)
                else:  # Post-fault
                    signal.append(self.Pmax)
            Signal.append(signal)
            Pmax = np.asarray(Signal).T
            self.U = Pmax
            self.nu = 1
        return self.U

    def equations(self, x, t, u):
        delta = x[0]
        domega = x[1]

        if (self.mode == 0):
            Pm = u[0]
            Pmax = u[1]
        elif (self.mode == 1):
            Pm = u[0]
            Pmax = self.Pmax
        else:
            Pm = self.Pm
            Pmax = u[0]

        dx_dt = [self.ws * domega, (Pm - Pmax * np.sin(delta) - self.D * domega) / self.M]
        return dx_dt


class DuffingControl(ODE_NonAutonomous):
    """
    Duffing equation with driving force as a function of control inputs not time
    + https://en.wikipedia.org/wiki/Duffing_equation
    """

    def __init__(self, nsim=1001, ninit=0, ts=0.1, seed=59):
        super().__init__(nsim=nsim, ninit=ninit, ts=ts, seed=seed)
        self.delta = 0.02
        self.alpha = 1
        self.beta = 5
        self.gamma = 8
        self.omega = 0.5
        self.x0 = [1.0, 0.0]
        self.nx = 2
        self.nu = 1
        self.U = 0.5*np.cos([np.arange(0., nsim) * ts]).T
        self.get_stats()

    def equations(self, x, t, u):
        dx1 = x[1]
        dx2 = - self.delta*x[1] - self.alpha*x[0] - self.beta*x[0]**3 + \
              self.gamma*np.cos(self.omega*u[0])
        dx = [dx1, dx2]
        return dx


class VanDerPolControl(ODE_NonAutonomous):
    """
    Van der Pol oscillator

    + https://en.wikipedia.org/wiki/Van_der_Pol_oscillator
    + http://kitchingroup.cheme.cmu.edu/blog/2013/02/02/Solving-a-second-order-ode/
    + section V.A in: https://arxiv.org/abs/2203.14114
    """

    def __init__(self, nsim=1001, ninit=0, ts=0.02, seed=59):
        super().__init__(nsim=nsim, ninit=ninit, ts=ts, seed=seed)
        self.mu = 1.0
        # self.x0 = [1, 2]
        self.x0 = np.random.randn(2)
        self.nx = 2
        self.nu = 1
        self.U = np.cos([np.arange(0., nsim) * ts]).T
        self.get_stats()

    def equations(self, x, t, u):
        dx1 = x[1]
        dx2 = self.mu*(1 - x[0]**2)*x[1] - x[0] + u[0]
        dx = [dx1, dx2]
        return dx


class ThomasAttractorControl(ODE_NonAutonomous):
    """
    Thomas' cyclically symmetric attractor
    control input: dissipativity parameter b

    + https://en.wikipedia.org/wiki/Thomas%27_cyclically_symmetric_attractor
    """

    def __init__(self, nsim=1001, ninit=0, ts=0.1, seed=59):
        super().__init__(nsim=nsim, ninit=ninit, ts=ts, seed=seed)
        self.b = 0.208186    # chaos starts at this parameter point
        self.x0 = [1, -1, 1]
        self.nx = 3
        self.nu = 1
        self.U = self.get_U(nsim)
        self.get_stats()

    def get_U(self, nsim):
        return Steps(nx=1, nsim=nsim, values=[0.208186, 0.3289, 0.5, 1.0],
                     randsteps=int(np.ceil(nsim / 48)), xmax=1.0, xmin=0.) + WhiteNoise(1, nsim, xmax=.01, xmin=-.01)

    def equations(self, x, t, u):
        b = u[0]
        dx1 = np.sin(x[1]) - b*x[0]
        dx2 = np.sin(x[2]) - b*x[1]
        dx3 = np.sin(x[0]) - b*x[2]
        dx = [dx1, dx2, dx3]
        return dx


systems = dict(inspect.getmembers(sys.modules[__name__], lambda x: inspect.isclass(x)))
systems = {k: v for k, v in systems.items() if issubclass(v, ODE_NonAutonomous) and v is not ODE_NonAutonomous}


